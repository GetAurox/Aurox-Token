{
  "language": "Solidity",
  "sources": {
    "contracts/__mocks__/Token.sol": {
      "content": "pragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\ncontract Token is ERC20 {\n    constructor() ERC20(\"TOK\", \"TK\") {}\n\n    // Expose a new function to update the allowance of a new contract\n    function setAllowance(address allowanceAddress) external {\n        _approve(address(this), allowanceAddress, 650000 ether);\n    }\n\n    function increaseTokenAllowance(address _address, uint256 _amount)\n        external\n    {\n        increaseAllowance(_address, _amount);\n    }\n\n    function mint(address _address, uint256 _amount) external {\n        _mint(_address, _amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/Token/TokenVesting.sol": {
      "content": "pragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/**\n * @title TokenVesting\n * @dev A token holder contract that can release its token balance gradually like a\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\n * owner.\n */\ncontract TokenVesting is Ownable, ReentrancyGuard {\n    // The vesting schedule is time-based (i.e. using block timestamps as opposed to e.g. block numbers), and is\n    // therefore sensitive to timestamp manipulation (which is something miners can do, to a certain degree). Therefore,\n    // it is recommended to avoid using short time durations (less than a minute). Typical vesting schemes, with a\n    // cliff period of a year and a duration of four years, are safe to use.\n    // solhint-disable not-rely-on-time\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event TokensReleased(address token, uint256 amount);\n    event TokenVestingRevoked(address token);\n\n    // beneficiary of tokens after they are released\n    address private _beneficiary;\n\n    // Durations and timestamps are expressed in UNIX time, the same units as block.timestamp.\n    uint256 private _cliff;\n    uint256 private _start;\n    uint256 private _duration;\n\n    bool private _revocable;\n\n    mapping(address => uint256) private _released;\n    mapping(address => bool) private _revoked;\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyBeneficiary() {\n        require(\n            _msgSender() == _beneficiary,\n            \"Caller not the beneficiary of the Vesting amounts\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\n     * beneficiary, gradually in a linear fashion until start + duration. By then all\n     * of the balance will have vested.\n     * @param beneficiary address of the beneficiary to whom vested tokens are transferred\n     * @param cliffDuration duration in seconds of the cliff in which tokens will begin to vest\n     * @param start the time (as Unix time) at which point vesting starts\n     * @param duration duration in seconds of the period in which the tokens will vest\n     * @param revocable whether the vesting is revocable or not\n     */\n    constructor(\n        address beneficiary,\n        uint256 start,\n        uint256 cliffDuration,\n        uint256 duration,\n        bool revocable\n    ) {\n        require(\n            beneficiary != address(0),\n            \"TokenVesting: beneficiary is the zero address\"\n        );\n        // solhint-disable-next-line max-line-length\n        require(\n            cliffDuration <= duration,\n            \"TokenVesting: cliff is longer than duration\"\n        );\n        require(duration > 0, \"TokenVesting: duration is 0\");\n        // solhint-disable-next-line max-line-length\n        require(\n            start.add(duration) > block.timestamp,\n            \"TokenVesting: final time is before current time\"\n        );\n\n        _beneficiary = beneficiary;\n        _revocable = revocable;\n        _duration = duration;\n        _cliff = start.add(cliffDuration);\n        _start = start;\n    }\n\n    /**\n     * @return the beneficiary of the tokens.\n     */\n    function beneficiary() external view returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @return the cliff time of the token vesting.\n     */\n    function cliff() external view returns (uint256) {\n        return _cliff;\n    }\n\n    /**\n     * @return the start time of the token vesting.\n     */\n    function start() external view returns (uint256) {\n        return _start;\n    }\n\n    /**\n     * @return the duration of the token vesting.\n     */\n    function duration() external view returns (uint256) {\n        return _duration;\n    }\n\n    /**\n     * @return true if the vesting is revocable.\n     */\n    function revocable() external view returns (bool) {\n        return _revocable;\n    }\n\n    /**\n     * @return the amount of the token released.\n     */\n    function released(address token) external view returns (uint256) {\n        return _released[token];\n    }\n\n    /**\n     * @return true if the token is revoked.\n     */\n    function revoked(address token) external view returns (bool) {\n        return _revoked[token];\n    }\n\n    /**\n     * @notice Transfers vested tokens to beneficiary.\n     * @param token ERC20 token which is being vested\n     */\n    function release(IERC20 token) external onlyBeneficiary nonReentrant {\n        uint256 unreleased = _releasableAmount(token);\n\n        require(unreleased > 0, \"TokenVesting: no tokens are due\");\n\n        _released[address(token)] = _released[address(token)].add(unreleased);\n\n        token.safeTransfer(_beneficiary, unreleased);\n\n        emit TokensReleased(address(token), unreleased);\n    }\n\n    /**\n     * @notice Allows the owner to revoke the vesting. Tokens already vested\n     * remain in the contract, the rest are returned to the owner.\n     * @param token ERC20 token which is being vested\n     */\n    function revoke(IERC20 token) external onlyOwner nonReentrant {\n        require(_revocable, \"TokenVesting: cannot revoke\");\n        require(\n            !_revoked[address(token)],\n            \"TokenVesting: token already revoked\"\n        );\n\n        uint256 balance = token.balanceOf(address(this));\n\n        uint256 unreleased = _releasableAmount(token);\n        uint256 refund = balance.sub(unreleased);\n\n        _revoked[address(token)] = true;\n\n        token.safeTransfer(owner(), refund);\n\n        emit TokenVestingRevoked(address(token));\n    }\n\n    /**\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\n     * @param token ERC20 token which is being vested\n     */\n    function _releasableAmount(IERC20 token) private view returns (uint256) {\n        return _vestedAmount(token).sub(_released[address(token)]);\n    }\n\n    /**\n     * @dev Calculates the amount that has already vested.\n     * @param token ERC20 token which is being vested\n     */\n    function _vestedAmount(IERC20 token) private view returns (uint256) {\n        uint256 currentBalance = token.balanceOf(address(this));\n        uint256 totalBalance = currentBalance.add(_released[address(token)]);\n\n        if (block.timestamp < _cliff) {\n            return 0;\n        } else if (\n            block.timestamp >= _start.add(_duration) || _revoked[address(token)]\n        ) {\n            return totalBalance;\n        } else {\n            return totalBalance.mul(block.timestamp.sub(_start)).div(_duration);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/StakingMaster/StakingMaster.sol": {
      "content": "pragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./IStakingMaster.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n// This contract contains a number of time-sensitive actions, it is widely known that time-sensitive actions can be manipulated by the miners reporting of time. This is not believed to be an issue within these contracts because it is dealing only with large time increments (weeks/months) and a miner can only influence the time reporting by ~15 seconds. It is accepted that time dependence events are allowed if they can vary by roughly 15 seconds and still maintain integrity.\n\ncontract StakingMaster is IStakingMaster, Context, Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    using SafeERC20 for IERC20;\n\n    IERC20 private auroxToken;\n\n    address private providerAddress;\n\n    // Store the static to prevent re-calculation's later on\n    uint256 private secondsPerMonth = 2629746;\n\n    // uint256 private secondsInAFortnight = secondsPerMonth / 2;\n\n    // Keep track of the total invested amount\n    uint256 public investedTotal = 0;\n\n    uint256 private epochStart;\n\n    // Make this a uint160 so its compatible with the address conversion\n    uint160 public localCreationCount = 0;\n\n    uint256 public poolRewardsTotal = 0;\n\n    mapping(address => Staking) public staking;\n\n    mapping(address => address[]) private userInvestments;\n\n    // If the user accidentally transfers ETH into the contract, revert the transfer\n    fallback() external payable {\n        revert();\n    }\n\n    event CreateStaking(\n        address indexed _from,\n        address stakeAddress,\n        uint256 _stakeEndTime,\n        uint256 _amount\n    );\n\n    event AddToStake(address indexed stakeAddress, uint256 _amount);\n\n    event ClaimRewards(\n        address indexed _from,\n        address indexed stakeAddress,\n        uint256 _claimableAmount,\n        uint256 _claimablePoolRewards\n    );\n\n    event CloseStaking(\n        address indexed _from,\n        address stakeAddress,\n        uint256 _claimAmount,\n        uint256 _penaltyAmount\n    );\n\n    event UpdateProviderAddress(address indexed _newAddress);\n\n    modifier onlyStakeOwner(address _stakingAddress) {\n        require(\n            _stakingAddress != address(0x0),\n            \"StakingMaster: Staking address can't be the 0 address\"\n        );\n\n        address[] memory usersStakes = userInvestments[_msgSender()];\n\n        address foundStake;\n\n        for (uint8 index = 0; index < usersStakes.length; index++) {\n            if (usersStakes[index] == _stakingAddress) {\n                foundStake = usersStakes[index];\n            }\n        }\n\n        require(\n            foundStake != address(0),\n            \"StakingMaster: User doesn't own the stake\"\n        );\n\n        _;\n    }\n\n    constructor(address _auroxAddress, uint256 _epochStart) {\n        auroxToken = IERC20(_auroxAddress);\n        epochStart = _epochStart;\n    }\n\n    /**\n        @dev Allows the owner to set the provider address for checking if interactions are from the provider. Allow this to be overwritten in case of redeployments\n        @param _providerAddress The contract address of the provider\n     */\n    function setProviderAddress(address _providerAddress)\n        external\n        nonReentrant\n        onlyOwner\n    {\n        providerAddress = _providerAddress;\n\n        emit UpdateProviderAddress(_providerAddress);\n    }\n\n    // Function to return a given user's total stake value including all interest earnt up until the current point\n    function returnUsersTotalStakeValue(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 totalStakeValue;\n\n        address[] memory usersStakes = userInvestments[_user];\n\n        for (uint8 index = 0; index < usersStakes.length; index++) {\n            uint256 currentStakeValue = returnCurrentStakeValue(\n                usersStakes[index]\n            );\n\n            totalStakeValue = totalStakeValue.add(currentStakeValue);\n        }\n\n        return totalStakeValue;\n    }\n\n    // This function is intended to be called by the provider contract when the provider contract is adding rewards to a stake. It takes in a user's address as a parameter and returns a \"valid\" stake; a stake that is in progress and was created by the provider previously.\n    function returnValidUsersProviderStake(address _user)\n        external\n        view\n        override\n        returns (address)\n    {\n        address[] memory usersStakes = userInvestments[_user];\n\n        for (uint8 index = 0; index < usersStakes.length; index++) {\n            address currentStake = usersStakes[index];\n            if (\n                staking[currentStake].providerStake == true &&\n                staking[currentStake].stakeEndTime > block.timestamp\n            ) {\n                return usersStakes[index];\n            }\n        }\n        // If no valid stakes found\n        return address(0);\n    }\n\n    // Returns the interest percentage that a user is entitled to, based on the parameters\n    function returnInterestPercentage(\n        uint256 _duration,\n        bool _epochOne,\n        bool _fromStakingContract\n    ) public view returns (uint256) {\n        uint256 interestRate;\n        uint256 maxInterestRate = uint256(20 ether).div(100);\n        // Convert the duration into the proper base so the returned interest value has 18 decimals and 1e18 = 100%\n        uint256 updatedDuration = _duration.mul(uint256(1 ether).div(100));\n\n        // Calculate the initial interest rate as the months / 2\n        interestRate = updatedDuration.div(2);\n\n        // If the interest rate exceeds 20% set it to 20%\n        if (interestRate > maxInterestRate) {\n            interestRate = maxInterestRate;\n        }\n\n        if (_epochOne && _duration >= 12) {\n            // If the amount is from epoch 1 then add 50% to the APY\n            interestRate = interestRate.add(interestRate.div(2));\n        } else if (_fromStakingContract) {\n            // If the amount is from the liquidity contract then add 25% to the APY\n            interestRate = interestRate.add(interestRate.div(4));\n        }\n\n        return interestRate;\n    }\n\n    // Return the simple interest based on the given parameters\n    function returnSimpleInterest(\n        uint256 _amount,\n        uint256 _interest,\n        uint256 _duration\n    ) public view returns (uint256) {\n        // Divide by 1 ether to remove the added decimals from multiplying the interest with 18 decimals by the amount with 18 decimals\n        return\n            _amount.add(\n                _interest\n                    .mul(_amount)\n                    .div(1 ether)\n                    .mul(_duration)\n                    .div(secondsPerMonth)\n                    .div(uint256(12))\n            );\n    }\n\n    // Return the compound interest based on the given parameters\n    function returnCompoundInterest(\n        uint256 _amount,\n        uint256 _interest,\n        uint256 _duration\n    ) public view returns (uint256) {\n        // Store this constant divider value so it doesn't get recomputed each loop\n        uint256 divider = uint256(1 ether).mul(uint256(12));\n        // Calculate the compound interest over all complete months\n        for (uint256 i = 0; i < _duration.div(secondsPerMonth); i++) {\n            // Calculate the simple interest for the entire year then divide by 12 (The number of times compounding per year)\n            _amount = _amount.add(_interest.mul(_amount).div(divider));\n        }\n\n        uint256 leftOverMonthSeconds = _duration.mod(secondsPerMonth);\n        // Calculate the interest for the last left-over month\n        if (leftOverMonthSeconds > 0) {\n            // Calculates the interest for the left-over incomplete  month: interest * amount * (leftOverSeconds/secondsPerMonth) / 12\n            _amount = _amount.add(\n                _interest\n                    .mul(_amount)\n                    .div(1 ether)\n                    .mul(leftOverMonthSeconds)\n                    .div(secondsPerMonth)\n                    .div(uint256(12))\n            );\n        }\n        return _amount;\n    }\n\n    // Function to delegate the call to either a simple interest calculation or compound depending on the compounding parameter\n    function returnTotalInterestAmount(\n        uint256 _durationInSeconds,\n        uint256 _interestRate,\n        uint256 _amount,\n        bool compounding\n    ) public view returns (uint256) {\n        if (compounding) {\n            uint256 total = returnCompoundInterest(\n                _amount,\n                _interestRate,\n                _durationInSeconds\n            );\n            return total.sub(_amount);\n        } else {\n            uint256 total = returnSimpleInterest(\n                _amount,\n                _interestRate,\n                _durationInSeconds\n            );\n            return total.sub(_amount);\n        }\n    }\n\n    // Create a stake for the user given the parameters\n    function createStaking(\n        uint256 _amount,\n        uint256 _duration,\n        address _recipient\n    ) external override nonReentrant {\n        require(_amount > 0, \"Amount to create stake must be greater than 0\");\n        require(_duration > 0, \"Duration must be longer than 0 months\");\n        require(\n            _duration <= 84,\n            \"Duration must be less than or equal to 7 years\"\n        );\n        require(\n            _recipient != address(0x0),\n            \"Recipient address can't be the 0x0 address\"\n        );\n\n        bool _fromProviderContract = false;\n\n        // If the sender was the provider contract then give the interest rate boost\n        if (_msgSender() == providerAddress) {\n            _fromProviderContract = true;\n        }\n\n        bool _epochOne = false;\n\n        // If the current time is within the first epoch and the amount came from the provider contract\n        if (\n            block.timestamp <= epochStart.add(14 days) && _fromProviderContract\n        ) {\n            _epochOne = true;\n        }\n\n        // The expected interest rate for the user\n        uint256 interestRate = returnInterestPercentage(\n            _duration,\n            _epochOne,\n            _fromProviderContract\n        );\n\n        bool compounding = true;\n\n        // If the duration is less than 12 months then it is not compounding\n        if (_duration < 12) {\n            compounding = false;\n        }\n\n        // The entire staking duration in seconds\n        uint256 durationInSeconds = _duration.mul(secondsPerMonth);\n        // The total earned interest on the stake\n        uint256 interest = returnTotalInterestAmount(\n            durationInSeconds,\n            interestRate,\n            _amount,\n            compounding\n        );\n\n        if (_fromProviderContract == false) {\n            // Do this in this manner so you don't need to check for math underflows\n            // Add the interest amount to the public funds balance\n            uint256 auroxBalance = auroxToken.balanceOf(address(auroxToken));\n\n            require(\n                auroxBalance >= uint256(30000 ether).add(interest),\n                \"Balance of Aurox Token must be greater than 30k\"\n            );\n        }\n\n        uint256 totalLocked = _amount.add(interest);\n\n        localCreationCount = localCreationCount + 1;\n\n        address vestingContract = address(localCreationCount);\n\n        // Increase the overall invested total to include the additional amount + interest\n        investedTotal = investedTotal.add(totalLocked);\n\n        // Transfer the user's investment amount into the vesting contract, or transfer it from the public funds it the creator is the provider contract\n        if (_fromProviderContract) {\n            auroxToken.safeTransferFrom(\n                address(auroxToken),\n                address(this),\n                totalLocked\n            );\n        } else {\n            auroxToken.safeTransferFrom(_msgSender(), address(this), _amount);\n\n            auroxToken.safeTransferFrom(\n                address(auroxToken),\n                address(this),\n                interest\n            );\n        }\n\n        uint256 stakeEndTime = block.timestamp.add(durationInSeconds);\n\n        // Create the staking master struct to include the additional data\n        staking[vestingContract] = Staking(\n            _amount,\n            stakeEndTime,\n            interestRate,\n            block.timestamp,\n            compounding,\n            _amount,\n            block.timestamp,\n            _fromProviderContract,\n            0,\n            false,\n            totalLocked\n        );\n\n        // Add the created vesting contract to the user's investment mapping\n        userInvestments[_recipient].push(vestingContract);\n        // Emit event for creation if required\n        emit CreateStaking(\n            _msgSender(),\n            vestingContract,\n            stakeEndTime,\n            _amount\n        );\n    }\n\n    function saveRecreateStakeDetails(\n        RecreateStakeArgs calldata recreateStakeArgs\n    ) private {\n        investedTotal = investedTotal.add(recreateStakeArgs._balance);\n\n        localCreationCount = localCreationCount + 1;\n\n        address vestingContract = address(localCreationCount);\n\n        staking[vestingContract] = Staking(\n            recreateStakeArgs._investedAmount,\n            recreateStakeArgs._stakeEndTime,\n            recreateStakeArgs._interestRate,\n            recreateStakeArgs._lastUpdate,\n            recreateStakeArgs._compounded,\n            recreateStakeArgs._rawInvestedAmount,\n            recreateStakeArgs._stakeStartTime,\n            recreateStakeArgs._providerStake,\n            0,\n            false,\n            recreateStakeArgs._balance\n        );\n\n        userInvestments[recreateStakeArgs._recipient].push(vestingContract);\n\n        // Emit event for creation\n        emit CreateStaking(\n            _msgSender(),\n            vestingContract,\n            recreateStakeArgs._stakeEndTime,\n            recreateStakeArgs._rawInvestedAmount\n        );\n    }\n\n    function batchRecreateStake(RecreateStakeArgs[] calldata recreateStakeArgs)\n        external\n        override\n        nonReentrant\n        onlyOwner\n    {\n        uint256 transferTotal;\n\n        for (uint8 i = 0; i < recreateStakeArgs.length; i++) {\n            saveRecreateStakeDetails(recreateStakeArgs[i]);\n            transferTotal += recreateStakeArgs[i]._balance;\n        }\n\n        auroxToken.safeTransferFrom(_msgSender(), address(this), transferTotal);\n    }\n\n    function recreateStake(RecreateStakeArgs calldata recreateStakeArgs)\n        external\n        override\n        nonReentrant\n        onlyOwner\n    {\n        saveRecreateStakeDetails(recreateStakeArgs);\n\n        auroxToken.safeTransferFrom(\n            _msgSender(),\n            address(this),\n            recreateStakeArgs._balance\n        );\n    }\n\n    function addToStake(address _stakingAddress, uint256 _amount)\n        external\n        override\n        nonReentrant\n    {\n        require(\n            _stakingAddress != address(0x0),\n            \"Staking address can't be the 0x0 address\"\n        );\n        require(\n            _amount > 0,\n            \"Amount must be greater than 0 when adding to a stake\"\n        );\n\n        require(\n            _msgSender() == providerAddress,\n            \"Only the Provider contract can add to a stake\"\n        );\n\n        Staking storage stakingContract = staking[_stakingAddress];\n\n        require(\n            stakingContract.providerStake,\n            \"StakingMaster: To add to a stake it must be a provider stake\"\n        );\n        require(\n            stakingContract.stakeEndTime > block.timestamp,\n            \"StakingMaster: Staking contract has finished\"\n        );\n        // Calculate seconds left in the stake, so that the interest calculation isn't from the start of the stake and is from now\n        uint256 secondsLeft = stakingContract.stakeEndTime.sub(block.timestamp);\n\n        // The expected interest for the additional amount\n        uint256 interest = returnTotalInterestAmount(\n            secondsLeft,\n            stakingContract.interestRate,\n            _amount,\n            stakingContract.compounded\n        );\n\n        uint256 totalAddedToLocked = _amount.add(interest);\n\n        uint256 timeElapsedSinceLastUpdate = block.timestamp.sub(\n            stakingContract.lastUpdate\n        );\n\n        // Calculate the earned interest up to now.\n        uint256 currentInterestAmount = returnTotalInterestAmount(\n            timeElapsedSinceLastUpdate,\n            stakingContract.interestRate,\n            stakingContract.investedAmount,\n            stakingContract.compounded\n        );\n\n        // Add the new amount to the invested total + the expected interest on that additional amount\n        investedTotal = investedTotal.add(totalAddedToLocked);\n\n        // Update the user's invested amount to include interest up to now + the new amount. This simplifies calculating interest later on.\n        stakingContract.investedAmount = stakingContract.investedAmount.add(\n            _amount.add(currentInterestAmount)\n        );\n\n        // Used to calculate the stake value later on\n        stakingContract.lastUpdate = block.timestamp;\n        // Add the raw value to the amount\n        stakingContract.rawInvestedAmount = stakingContract\n            .rawInvestedAmount\n            .add(_amount);\n\n        stakingContract.totalLocked = stakingContract.totalLocked.add(\n            totalAddedToLocked\n        );\n\n        auroxToken.safeTransferFrom(\n            address(auroxToken),\n            address(this),\n            totalAddedToLocked\n        );\n\n        emit AddToStake(_stakingAddress, _amount);\n    }\n\n    function returnStakeState(address _stakingAddress)\n        external\n        view\n        override\n        returns (\n            uint256 currentStakeValue,\n            uint256 stakeEndTime,\n            uint256 interestRate,\n            uint256 lastUpdate,\n            bool compounding,\n            uint256 rawInvestedAmount,\n            uint256 stakeStartTime\n        )\n    {\n        Staking memory stake = staking[_stakingAddress];\n\n        // Return the current stake value including interest up until this point\n        uint256 stakesValue = returnCurrentStakeValue(_stakingAddress);\n        return (\n            stakesValue,\n            stake.stakeEndTime,\n            stake.interestRate,\n            stake.lastUpdate,\n            stake.compounded,\n            stake.rawInvestedAmount,\n            stake.stakeStartTime\n        );\n    }\n\n    // Return all the user's created Staking Contracts\n    function returnUsersStakes(address _user)\n        external\n        view\n        override\n        returns (address[] memory usersStakes)\n    {\n        return userInvestments[_user];\n    }\n\n    // The alternative to this loop is creating a mapping of indexes and an array of addresses. This allows fetching the stakes index directly without looping. But to enable that you must write and delete an additional time, this increases the gas cost more than this loop.\n    function removeUsersStake(address stakeToRemove) private {\n        address[] memory usersStakes = userInvestments[_msgSender()];\n        uint8 index = 0;\n        // Interate over each stake to find the matching one\n        for (uint256 i = 0; i < usersStakes.length; i++) {\n            if (usersStakes[i] == stakeToRemove) {\n                index = uint8(i);\n                break;\n            }\n        }\n        // If the stake is found update the array\n        if (usersStakes.length > 1) {\n            userInvestments[_msgSender()][index] = usersStakes[\n                usersStakes.length - 1\n            ];\n        }\n        // Remove last item\n        userInvestments[_msgSender()].pop();\n    }\n\n    // Function to return the staked value including all generated interest up until the now\n    function returnCurrentStakeValue(address _stakingAddress)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        Staking memory stake = staking[_stakingAddress];\n        uint256 timeElapsedSinceLastUpdate;\n\n        // If the stake is complete\n        if (stake.stakeEndTime < block.timestamp) {\n            timeElapsedSinceLastUpdate = stake.stakeEndTime.sub(\n                stake.lastUpdate\n            );\n        } else {\n            timeElapsedSinceLastUpdate = block.timestamp.sub(stake.lastUpdate);\n        }\n\n        uint256 interest = returnTotalInterestAmount(\n            timeElapsedSinceLastUpdate,\n            stake.interestRate,\n            stake.investedAmount,\n            stake.compounded\n        );\n\n        return stake.investedAmount.add(interest);\n    }\n\n    function returnStakesClaimablePoolRewards(address _stakingAddress)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        Staking memory stakingContract = staking[_stakingAddress];\n\n        // If the user has claimed pool rewards before\n        if (stakingContract.poolRewardsClaimed) {\n            return 0;\n        }\n\n        // The user's share of the pool rewards\n        return\n            poolRewardsTotal.mul(stakingContract.totalLocked).div(\n                investedTotal\n            );\n    }\n\n    // This function returns a user's total claimable reward amount for any given time\n    function returnStakesClaimableRewards(address _stakingAddress)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        Staking memory stakingContract = staking[_stakingAddress];\n\n        // If the vesting hasn't started yet, vesting starts when the stake completes\n        if (stakingContract.stakeEndTime > block.timestamp) {\n            return 0;\n        }\n\n        uint256 vestingDuration = secondsPerMonth.div(2);\n\n        uint256 vestingEndTime = stakingContract.stakeEndTime.add(\n            vestingDuration\n        );\n\n        // If the vesting duration is complete return the amount - the amount that has been already released\n        if (block.timestamp >= vestingEndTime) {\n            return stakingContract.totalLocked.sub(stakingContract.released);\n        }\n\n        return\n            (\n                (\n                    stakingContract.totalLocked.mul(\n                        (block.timestamp.sub(stakingContract.stakeEndTime))\n                    )\n                ).div(vestingDuration)\n            ).sub(stakingContract.released);\n    }\n\n    // Function to claim rewards for a user, it releases the funds from the Vesting contract and calculates the user's share of the pool rewards\n    function claimRewards(address _stakingAddress)\n        external\n        override\n        nonReentrant\n        onlyStakeOwner(_stakingAddress)\n    {\n        Staking storage stakingContract = staking[_stakingAddress];\n\n        require(\n            stakingContract.stakeEndTime < block.timestamp,\n            \"StakingMaster: Stake is still in progress\"\n        );\n\n        uint256 claimablePoolRewards = 0;\n\n        if (!stakingContract.poolRewardsClaimed) {\n            // Pool rewards calculation here\n            claimablePoolRewards = returnStakesClaimablePoolRewards(\n                _stakingAddress\n            );\n\n            stakingContract.poolRewardsClaimed = true;\n\n            // Remove the user's amount from the investedTotal and from the poolRewardsTotal\n            investedTotal = investedTotal.sub(stakingContract.totalLocked);\n\n            poolRewardsTotal = poolRewardsTotal.sub(claimablePoolRewards);\n        }\n\n        uint256 claimableAmount = returnStakesClaimableRewards(_stakingAddress);\n\n        stakingContract.released = stakingContract.released.add(\n            claimableAmount\n        );\n\n        // If the user doesn't have additional rewards to claim from the vesting contract, delete it from the array and delete the struct\n        if (stakingContract.released == stakingContract.totalLocked) {\n            removeUsersStake(_stakingAddress);\n            // Delete the struct item\n            delete staking[_stakingAddress];\n        }\n\n        auroxToken.safeTransfer(_msgSender(), claimableAmount);\n        if (!stakingContract.poolRewardsClaimed && claimablePoolRewards > 0) {\n            auroxToken.safeTransfer(_msgSender(), claimablePoolRewards);\n        }\n\n        emit ClaimRewards(\n            _msgSender(),\n            _stakingAddress,\n            claimableAmount,\n            claimablePoolRewards\n        );\n    }\n\n    // This function calculates how much the user is entitled to when a stake is closed early\n    function returnClaimAmountForEarlyStakeClose(address _stakingAddress)\n        public\n        view\n        returns (uint256)\n    {\n        Staking memory stake = staking[_stakingAddress];\n\n        uint256 incompleteStakeTime = stake.stakeEndTime.sub(block.timestamp);\n\n        uint256 stakeTotalTime = stake.stakeEndTime.sub(stake.stakeStartTime);\n\n        uint256 penaltyTotal = stake\n            .rawInvestedAmount\n            .mul(incompleteStakeTime)\n            .div(stakeTotalTime)\n            .div(2);\n\n        // Return the raw amount and subtract the penalty total\n        return stake.rawInvestedAmount.sub(penaltyTotal);\n    }\n\n    // Close the staking contract with penalties\n    function closeStake(address _stakingAddress)\n        external\n        override\n        nonReentrant\n        onlyStakeOwner(_stakingAddress)\n    {\n        Staking storage stakingContract = staking[_stakingAddress];\n        // Require that the staking contract hasn't ended\n        require(\n            stakingContract.stakeEndTime > block.timestamp,\n            \"Staking contract has finished\"\n        );\n\n        investedTotal = investedTotal.sub(stakingContract.totalLocked);\n\n        // Calculate what the user is owed\n        uint256 claimAmount = returnClaimAmountForEarlyStakeClose(\n            _stakingAddress\n        );\n\n        uint256 penaltyAmount = stakingContract.totalLocked.sub(claimAmount);\n\n        poolRewardsTotal = poolRewardsTotal.add(penaltyAmount);\n\n        removeUsersStake(_stakingAddress);\n        // Delete the item from the array\n        delete staking[_stakingAddress];\n\n        // Transfer the amount the user is owed\n        auroxToken.safeTransfer(_msgSender(), claimAmount);\n\n        emit CloseStaking(\n            _msgSender(),\n            _stakingAddress,\n            claimAmount,\n            penaltyAmount\n        );\n    }\n}\n"
    },
    "contracts/StakingMaster/IStakingMaster.sol": {
      "content": "pragma solidity 0.8.10;\n\ninterface IStakingMaster {\n    /**\n        @dev The struct containing all of a stakes data\n     */\n    struct Staking {\n        uint256 investedAmount;\n        uint256 stakeEndTime;\n        uint256 interestRate;\n        uint256 lastUpdate;\n        bool compounded;\n        // The amount they add in at the start, un-modified\n        uint256 rawInvestedAmount;\n        uint256 stakeStartTime;\n        bool providerStake;\n        uint256 released;\n        bool poolRewardsClaimed;\n        uint256 totalLocked;\n    }\n\n    /**\n        @dev The struct containing all the fields to recreate a stake\n     */\n    struct RecreateStakeArgs {\n        uint256 _balance;\n        address _recipient;\n        uint256 _investedAmount;\n        uint256 _stakeEndTime;\n        uint256 _interestRate;\n        uint256 _lastUpdate;\n        bool _compounded;\n        uint256 _rawInvestedAmount;\n        uint256 _stakeStartTime;\n        bool _providerStake;\n    }\n\n    /**\n        @dev Returns a given user's total stake value across all the user's stakes, including all interest earnt up until now.\n        @param _user The user to return the value for\n        @return The users total stake value\n     */\n    function returnUsersTotalStakeValue(address _user)\n        external\n        view\n        returns (uint256);\n\n    /**\n        @dev Creates a new stake for the user. It calculates their projected interest based on the parameters and stores it in a TokenVesting contract that vests their total amount over 2 weeks once their stake is complete. It also creates a struct containing all the relevant stake details.\n        @param _amount The amount the user will be staking (in ether)\n        @param _duration The duration of the stake (in months)\n        @param _recipient The address of the user that will be receiving the stake rewards\n     */\n    function createStaking(\n        uint256 _amount,\n        uint256 _duration,\n        address _recipient\n    ) external;\n\n    /**\n        @dev This function allows the migration of a Stake contract from the previous StakingMaster\n        @param recreateStakeArgs All the arguments required to recreate the stake\n     */\n    function recreateStake(RecreateStakeArgs calldata recreateStakeArgs)\n        external;\n\n    /**\n        @dev This function allows the recreation of multiple stakes\n        @param recreateStakeArgs The array of arguments to recreate all the stakes\n     */\n    function batchRecreateStake(RecreateStakeArgs[] calldata recreateStakeArgs)\n        external;\n\n    /**\n        @dev Adds to a user's pre-existing stake. This can only be triggered by the Provider Contract, i.e; when a user is re-investing their rewards from the Provider Contract.\n        @param _stakingAddress The address of the stake\n        @param _amount The additional amount to stake\n     */\n    function addToStake(address _stakingAddress, uint256 _amount) external;\n\n    /**\n        @dev Claim rewards for a given stake. This releases the allowed amount from the Vesting contract and also returns them pool rewards. This can only be called when a stake is complete and by the _recipient of the stake only.\n        @param _stakingAddress The address of the stake\n     */\n    function claimRewards(address _stakingAddress) external;\n\n    /**\n        @dev Close the given stake, this can only happen when a stake is incomplete and User wishes to close the stake early. This function calculates their penalised amount for withdrawing early and stores it in the StakingMaster contract as the pool reward. It then transfers their allowed amount back to the user.\n        @param _stakingAddress The address of the stake\n     */\n    function closeStake(address _stakingAddress) external;\n\n    /* Helpers */\n\n    /**\n        @dev Returns a given stakes state\n        @param _stakingAddress The address of the stake\n\n        @return currentStakeValue The current value of the stake, including interest up until now\n        @return stakeEndTime When the stake will finish\n        @return interestRate The interest rate of the stake\n        @return lastUpdate When the stake last had value added to it, or when it was created (if no additional value has been added to the stake)\n        @return compounding Whether the stake is compounding\n        @return rawInvestedAmount The User's invested amount (excluding interest)\n        @return stakeStartTime When the stake was created\n     */\n    function returnStakeState(address _stakingAddress)\n        external\n        view\n        returns (\n            uint256 currentStakeValue,\n            uint256 stakeEndTime,\n            uint256 interestRate,\n            uint256 lastUpdate,\n            bool compounding,\n            uint256 rawInvestedAmount,\n            uint256 stakeStartTime\n        );\n\n    /**\n        @dev Returns a given user's stakes\n        @param _user The user to return stakes for\n\n        @return usersStakes An array containing the addreses of all the user's created stakes\n     */\n    function returnUsersStakes(address _user)\n        external\n        view\n        returns (address[] memory usersStakes);\n\n    /**\n        @dev Returns the given stake value corresponding to the stake address\n\n        @return _stakingAddress The staking address to return the value for\n     */\n    function returnCurrentStakeValue(address _stakingAddress)\n        external\n        view\n        returns (uint256);\n\n    /**\n        @dev Returns a user's staking address if the stake is in progress and was created by the provider contract. Function intended to be called by the provider contract when the user is claiming rewards and intending them to be sent to a Staking contract\n        @param _user The user to return valid stakes for\n\n        @return The valid stake address\n     */\n    function returnValidUsersProviderStake(address _user)\n        external\n        view\n        returns (address);\n\n    /**\n        @dev Returns a stakes claimable rewards, \n\n        @param _stakingAddress The stake to return the claimable rewards for\n\n        @return The claimable amount\n     */\n    function returnStakesClaimableRewards(address _stakingAddress)\n        external\n        view\n        returns (uint256);\n\n    /**\n        @dev Returns a stakes claimable pool rewards\n\n        @param _stakingAddress The stake to return the claimable pool rewards for\n\n        @return The claimable pool reward amount\n     */\n    function returnStakesClaimablePoolRewards(address _stakingAddress)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/TestHelpers/ERC20.sol": {
      "content": "pragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(\n                subtractedValue,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(\n            amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(\n            amount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(\n            account,\n            _msgSender(),\n            _allowances[account][_msgSender()].sub(\n                amount,\n                \"ERC20: burn amount exceeds allowance\"\n            )\n        );\n    }\n}\n"
    },
    "contracts/TestHelpers/ERC20Mintable.sol": {
      "content": "pragma solidity 0.8.10;\n\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20 {\n    constructor() public ERC20(\"UniSwap\", \"UNI-V2\") {}\n\n    /**\n     * @dev See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the {MinterRole}.\n     */\n    function mint(address account, uint256 amount) public returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n"
    },
    "contracts/Provider/RewardHelpers.sol": {
      "content": "pragma solidity 0.8.10;\n\nimport \"./EpochHelpers.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract RewardHelpers is EpochHelpers {\n    using SafeMath for uint256;\n\n    uint256 public lastEpochUpdate = 1;\n\n    // Function to calculate rewards over a year (26 epochs)\n    function returnCurrentAPY() external view returns (uint256) {\n        uint256 currentEpoch = returnCurrentEpoch();\n        uint256 totalReward;\n        // Checks if there is epochs that have rewards that aren't equal to 600\n        if (currentEpoch < 10) {\n            // The amount of epochs where the rewards aren't equal to 600\n            uint256 epochLoops = uint256(10).sub(currentEpoch);\n            // Iterate over each epoch to grab rewards for each of those epochs\n            for (\n                uint256 i = currentEpoch;\n                i < epochLoops.add(currentEpoch);\n                i++\n            ) {\n                uint256 epochReward = returnTotalRewardForEpoch(i);\n                totalReward = totalReward.add(epochReward);\n            }\n            // Add in $600 rewards for every epoch where the rewards are equal to 600\n            totalReward = totalReward.add(\n                uint256(600 ether).mul(uint256(26).sub(epochLoops))\n            );\n        } else {\n            // Every epoch has rewards equal to $600\n            totalReward = uint256(600 ether).mul(26);\n        }\n\n        // The overall total for all users\n        uint256 overallEpochTotal = _returnEpochAmountIncludingCurrentTotal(\n            epochAmounts[lastEpochUpdate]\n        );\n\n        // If 0 for the epoch total, set it to 1\n        if (overallEpochTotal == 0) {\n            overallEpochTotal = 1 ether;\n        }\n        uint256 totalAPY = totalReward.mul(1 ether).div(overallEpochTotal);\n\n        return totalAPY;\n    }\n\n    function _returnClaimSecondsForPulledLiquidity(\n        uint256 lastClaimedTimestamp,\n        uint256 currentEpoch\n    ) public view returns (uint256) {\n        uint256 lastClaimedEpoch = _returnEpochToTimestamp(\n            lastClaimedTimestamp\n        );\n\n        uint256 claimSecondsForPulledLiquidity;\n\n        if (lastClaimedEpoch == currentEpoch) {\n            // If they've claimed in this epoch, they should only be able to claim from when they last claimed to now\n            return\n                claimSecondsForPulledLiquidity = block.timestamp.sub(\n                    lastClaimedTimestamp\n                );\n        } else {\n            // If they haven't claimed in this epoch, then the claim seconds are from when the epoch start to now\n            uint256 secondsToEpochEnd = _getSecondsToEpochEnd(currentEpoch);\n\n            return epochLength.sub(secondsToEpochEnd);\n        }\n    }\n\n    // Returns the seconds that a user can claim rewards for in any given epoch\n    function _returnEpochClaimSeconds(\n        uint256 epoch,\n        uint256 currentEpoch,\n        uint256 lastEpochClaimed,\n        uint256 lastClaimedTimestamp\n    ) public view returns (uint256) {\n        // If the given epoch is the current epoch\n        if (epoch == currentEpoch) {\n            // If the user claimed rewards in this epoch, the claim seconds would be the block.timestamp - lastClaimedtimestamp\n            if (lastEpochClaimed == currentEpoch) {\n                return block.timestamp.sub(lastClaimedTimestamp);\n            }\n            // If the user hasn't claimed in this epoch, the claim seconds is the timestamp - startOfEpoch\n            uint256 givenEpochStartTime = returnGivenEpochStartTime(epoch);\n\n            return block.timestamp.sub(givenEpochStartTime);\n            // If the user last claimed in the given epoch, but it isn't the current epoch\n        } else if (lastEpochClaimed == epoch) {\n            // The claim seconds is the end of the given epoch - the lastClaimed timestmap\n            uint256 givenEpochEndTime = returnGivenEpochEndTime(epoch);\n            // If they've already claimed rewards in this epoch, calculate their claim seconds as the difference between that timestamp and now.\n\n            return givenEpochEndTime.sub(lastClaimedTimestamp);\n        }\n\n        // Return full length of epoch if it isn't the current epoch and the user hasn't previously claimed in this epoch.\n        return epochLength;\n    }\n\n    function _returnRewardAmount(\n        uint256 usersInvestmentTotal,\n        uint256 overallInvestmentTotal,\n        uint256 secondsToClaim,\n        uint256 totalReward\n    ) public view returns (uint256) {\n        // Calculate the total epoch reward share as: totalReward * usersInvestmentTotal / overallEpochTotal\n        uint256 totalEpochRewardShare = totalReward\n            .mul(usersInvestmentTotal)\n            .div(overallInvestmentTotal);\n\n        // Calculate the proportional reward share as totalEpochRewardShare * secondsToClaim / epochLength\n        uint256 proportionalRewardShare = totalEpochRewardShare\n            .mul(secondsToClaim)\n            .div(epochLength);\n        // totalReward * (usersInvestmentTotal / overallEpochTotal) * (secondsToClaim / epochLength)\n\n        return proportionalRewardShare;\n    }\n\n    function _calculateRewardShareForEpoch(\n        uint256 epoch,\n        uint256 currentEpoch,\n        uint256 lastEpochClaimed,\n        uint256 lastClaimedTimestamp,\n        uint256 usersInvestmentTotal,\n        uint256 overallInvestmentTotal\n    ) internal view returns (uint256) {\n        // If the last claimed timestamp is the same epoch as the epoch passed in\n        uint256 claimSeconds = _returnEpochClaimSeconds(\n            epoch,\n            currentEpoch,\n            lastEpochClaimed,\n            lastClaimedTimestamp\n        );\n\n        // Total rewards in the given epoch\n        uint256 totalEpochRewards = returnTotalRewardForEpoch(epoch);\n\n        return\n            _returnRewardAmount(\n                usersInvestmentTotal,\n                overallInvestmentTotal,\n                claimSeconds,\n                totalEpochRewards\n            );\n    }\n}\n"
    },
    "contracts/Provider/EpochHelpers.sol": {
      "content": "pragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract EpochHelpers {\n    using SafeMath for uint256;\n\n    struct EpochInvestmentDetails {\n        // Sum of all normalised epoch values\n        uint256 shareTotal;\n        // Sum of all liquidity amounts from the previous epochs\n        uint256 allPrevInvestmentTotals;\n        // Sum of all liquidity amounts, excluding amounts from the current epoch. This is so the share amounts aren't included twice.\n        uint256 currentInvestmentTotal;\n        // Boolean to hold whether liquidity was withdrawn in this epoch\n        bool withdrewLiquidity;\n    }\n\n    uint256 internal epochStart;\n    uint256 internal epochLength = 14 days;\n\n    // For storing overall details\n    mapping(uint256 => EpochInvestmentDetails) public epochAmounts;\n\n    function _returnEpochAmountIncludingShare(\n        EpochInvestmentDetails memory epochInvestmentDetails\n    ) internal pure returns (uint256) {\n        return\n            epochInvestmentDetails.allPrevInvestmentTotals.add(\n                epochInvestmentDetails.shareTotal\n            );\n    }\n\n    function _returnEpochAmountIncludingCurrentTotal(\n        EpochInvestmentDetails memory epochInvestmentDetails\n    ) internal view returns (uint256) {\n        return\n            epochInvestmentDetails.allPrevInvestmentTotals.add(\n                epochInvestmentDetails.currentInvestmentTotal\n            );\n    }\n\n    function returnGivenEpochEndTime(uint256 epoch)\n        public\n        view\n        returns (uint256)\n    {\n        return epochStart.add(epochLength.mul(epoch));\n    }\n\n    function returnGivenEpochStartTime(uint256 epoch)\n        public\n        view\n        returns (uint256)\n    {\n        return epochStart.add(epochLength.mul(epoch.sub(1)));\n    }\n\n    function returnCurrentEpoch() public view returns (uint256) {\n        return block.timestamp.sub(epochStart).div(epochLength).add(1);\n    }\n\n    function _returnEpochToTimestamp(uint256 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        // ((timestamp - epochStart) / epochLength) + 1;\n        // Add 1 to the end because it will round down the remainder value\n        return timestamp.sub(epochStart).div(epochLength).add(1);\n    }\n\n    function _getSecondsToEpochEnd(uint256 currentEpoch)\n        public\n        view\n        returns (uint256)\n    {\n        // Add to the epoch start date the duration of the current epoch + 1 * the epoch length.\n        // Then subtract the block.timestamp to get the duration to the next epoch\n        // epochStart + (currentEpoch * epochLength) - block.timestamp\n        uint256 epochEndTime = epochStart.add(currentEpoch.mul(epochLength));\n        // Prevent a math underflow by returning 0 if the given epoch is complete\n        if (epochEndTime < block.timestamp) {\n            return 0;\n        } else {\n            return epochEndTime.sub(block.timestamp);\n        }\n    }\n\n    // The actual epoch rewards are 750 per week. But that shouldn't affect this\n    // If claiming from an epoch that is in-progress you would get a proportion anyway\n    function returnTotalRewardForEpoch(uint256 epoch)\n        public\n        pure\n        returns (uint256)\n    {\n        // If the epoch is greater than or equal to 10 return 600 as the reward. This prevents a safemath underflow\n        if (epoch >= 10) {\n            return 600 ether;\n        }\n        // 1500 - (epoch * 100)\n        uint256 rewardTotal = uint256(1500 ether).sub(\n            uint256(100 ether).mul(epoch.sub(1))\n        );\n\n        return rewardTotal;\n    }\n\n    function returnIfInFirstDayOfEpoch(uint256 currentEpoch)\n        public\n        view\n        returns (bool)\n    {\n        uint256 secondsToEpochEnd = _getSecondsToEpochEnd(currentEpoch);\n        // The subtraction overflows the the currentEpoch value passed in isn't the current epoch and a future epoch\n        uint256 secondsToEpochStart = epochLength.sub(secondsToEpochEnd);\n\n        // If the seconds to epoch start is less than 1 day then true\n        if (secondsToEpochStart <= 1 days) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "contracts/Provider/Provider.sol": {
      "content": "pragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../StakingMaster/IStakingMaster.sol\";\nimport \"./IProvider.sol\";\nimport \"./EpochHelpers.sol\";\nimport \"./RewardHelpers.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Provider is\n    IProvider,\n    Context,\n    ReentrancyGuard,\n    EpochHelpers,\n    RewardHelpers\n{\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 private UniSwapToken;\n\n    IERC20 private AuroxToken;\n\n    IStakingMaster private StakingMasterContract;\n\n    address public migrationContractAddress;\n\n    // For storing user details\n    mapping(address => UserDetails) public userInvestments;\n\n    // If the user accidentally transfers ETH into the contract, revert the transfer\n    fallback() external payable {\n        revert(\"Cannot send ether to this contract\");\n    }\n\n    // Events for the various actions\n    event AddLiquidity(address indexed _from, uint256 _amount);\n\n    event RemoveLiquidity(address indexed _from, uint256 _amount);\n\n    event ClaimRewards(\n        address indexed _from,\n        uint256 _amount,\n        bool indexed _sendRewardsToStaking\n    );\n\n    constructor(\n        address _uniSwapTokenAddress,\n        address _auroxTokenAddress,\n        address _stakingMaster,\n        uint256 _epochStart,\n        address _migrationContractAddress\n    ) {\n        epochStart = _epochStart;\n        UniSwapToken = IERC20(_uniSwapTokenAddress);\n        AuroxToken = IERC20(_auroxTokenAddress);\n        StakingMasterContract = IStakingMaster(_stakingMaster);\n\n        migrationContractAddress = _migrationContractAddress;\n    }\n\n    // Return the users total investment amount\n    function returnUsersInvestmentTotal(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        EpochInvestmentDetails memory latestInvestmentDetails = userInvestments[\n            _user\n        ].epochTotals[userInvestments[_user].lastEpochUpdate];\n        // Return the users investment total based on the epoch they edited last\n        uint256 investmentTotal = _returnEpochAmountIncludingCurrentTotal(\n            latestInvestmentDetails\n        );\n        return (investmentTotal);\n    }\n\n    // Returns a user's epoch totals for a given epoch\n    function returnUsersEpochTotals(uint256 epoch, address _user)\n        external\n        view\n        override\n        returns (\n            uint256 shareTotal,\n            uint256 currentInvestmentTotal,\n            uint256 allPrevInvestmentTotals\n        )\n    {\n        EpochInvestmentDetails memory investmentDetails = userInvestments[_user]\n            .epochTotals[epoch];\n        return (\n            investmentDetails.shareTotal,\n            investmentDetails.currentInvestmentTotal,\n            investmentDetails.allPrevInvestmentTotals\n        );\n    }\n\n    function returnEpochShare(uint256 _amount, uint256 currentEpoch)\n        public\n        returns (uint256 share)\n    {\n        uint256 secondsToEpochEnd = _getSecondsToEpochEnd(currentEpoch);\n\n        return _amount.mul(secondsToEpochEnd).div(epochLength);\n    }\n\n    function _updateUserDetailsAndEpochAmounts(\n        address _userAddress,\n        uint256 _amount\n    ) internal {\n        // Get the current epoch\n        uint256 currentEpoch = _returnEpochToTimestamp(block.timestamp);\n\n        UserDetails storage currentUser = userInvestments[_userAddress];\n\n        if (currentUser.lastEpochUpdate == 0) {\n            // Set the epoch for grabbing values to be this epoch.\n            currentUser.lastLiquidityAddedEpochReference = currentEpoch;\n\n            // Update when they last claimed to now, so they can't claim rewards for past epochs\n            currentUser.lastClaimedTimestamp = block.timestamp;\n        }\n\n        uint256 usersTotal = _returnEpochAmountIncludingCurrentTotal(\n            currentUser.epochTotals[currentUser.lastEpochUpdate]\n        );\n        // If they havent had an amount in the liquidity provider reset their boost reward, so they don't unexpectedly have a 100% boost reward immediately\n        if (usersTotal == 0) {\n            // Breaking tests when removed\n            currentUser.lastEpochLiquidityWithdrawn = currentEpoch;\n\n            // If they've claimed all rewards for their past investments, reset their last claimed timestamp to prevent them from looping uselessly\n            uint256 lastClaimedEpoch = _returnEpochToTimestamp(\n                currentUser.lastClaimedTimestamp\n            );\n            if (lastClaimedEpoch > currentUser.lastEpochUpdate) {\n                currentUser.lastClaimedTimestamp = block.timestamp;\n            }\n        }\n\n        // Normalise the epoch share as amount * secondsToEpochEnd / epochlength;\n        uint256 epochShare = returnEpochShare(_amount, currentEpoch);\n\n        // If the user hasn't added to the current epoch, carry over their investment total into the current epoch totals and update the reference for grabbing up to date user totals\n        if (currentUser.lastEpochUpdate < currentEpoch) {\n            // The pulled forward user's total investment amount\n            uint256 allPrevInvestmentTotals = currentUser\n                .epochTotals[currentUser.lastEpochUpdate]\n                .allPrevInvestmentTotals;\n\n            // Add the allPrevInvestmentTotals to the currentInvestmentTotal to reflect the new overall investment total\n            uint256 pulledForwardTotal = allPrevInvestmentTotals.add(\n                currentUser\n                    .epochTotals[currentUser.lastEpochUpdate]\n                    .currentInvestmentTotal\n            );\n\n            // Update the investment total by pulling forward the total amount from when the user last added liquidity\n            currentUser\n                .epochTotals[currentEpoch]\n                .allPrevInvestmentTotals = pulledForwardTotal;\n\n            // Update when liquidity was added last\n            currentUser.lastEpochUpdate = currentEpoch;\n        }\n\n        // Update the share total for the current epoch\n\n        currentUser.epochTotals[currentEpoch].shareTotal = currentUser\n            .epochTotals[currentEpoch]\n            .shareTotal\n            .add(epochShare);\n\n        // Update the user's currentInvestmentTotal to include the added amount\n        currentUser\n            .epochTotals[currentEpoch]\n            .currentInvestmentTotal = currentUser\n            .epochTotals[currentEpoch]\n            .currentInvestmentTotal\n            .add(_amount);\n\n        /* Do the same calculations but add it to the overall totals not the users */\n\n        // If the investment total hasn't been carried over into the \"new\" epoch\n        if (lastEpochUpdate < currentEpoch) {\n            // The pulled forward everyone's total amount\n            uint256 allPrevInvestmentTotals = epochAmounts[lastEpochUpdate]\n                .allPrevInvestmentTotals;\n\n            // The total pulled forward amount, including investments made on that epoch.\n            uint256 overallPulledForwardTotal = allPrevInvestmentTotals.add(\n                epochAmounts[lastEpochUpdate].currentInvestmentTotal\n            );\n\n            // Update the current epoch investment total to have the pulled forward totals from all other epochs.\n            epochAmounts[currentEpoch]\n                .allPrevInvestmentTotals = overallPulledForwardTotal;\n\n            // Update the lastEpochUpdate value\n            lastEpochUpdate = currentEpoch;\n        }\n\n        // Update the share total for everyone to include the additional amount\n        epochAmounts[currentEpoch].shareTotal = epochAmounts[currentEpoch]\n            .shareTotal\n            .add(epochShare);\n\n        // Update the current investment total for everyone\n        epochAmounts[currentEpoch].currentInvestmentTotal = epochAmounts[\n            currentEpoch\n        ].currentInvestmentTotal.add(_amount);\n    }\n\n    function addLiquidity(uint256 _amount) external override nonReentrant {\n        require(block.timestamp > epochStart, \"Epoch one hasn't started yet\");\n        require(_amount != 0, \"Cannot add a 0 amount\");\n\n        require(\n            UniSwapToken.allowance(_msgSender(), address(this)) >= _amount,\n            \"Allowance of Provider not large enough for the required amount\"\n        );\n        // Require the user to have enough balance for the transfer amount\n        require(\n            UniSwapToken.balanceOf(_msgSender()) >= _amount,\n            \"Balance of the sender not large enough for the required amount\"\n        );\n\n        _updateUserDetailsAndEpochAmounts(_msgSender(), _amount);\n\n        UniSwapToken.safeTransferFrom(_msgSender(), address(this), _amount);\n\n        emit AddLiquidity(_msgSender(), _amount);\n    }\n\n    function applyEpochRewardBonus(\n        uint256 _epochBonusMultiplier,\n        uint256 _epochRewards\n    ) private pure returns (uint256) {\n        if (_epochBonusMultiplier > 10) {\n            _epochBonusMultiplier = 10;\n        }\n\n        return\n            _epochRewards.add(_epochRewards.mul(_epochBonusMultiplier).div(10));\n    }\n\n    function saveMigrationUserDetails(\n        MigrateArgs calldata migrateArgs,\n        uint256 currentEpoch\n    ) private {\n        UserDetails storage currentUser = userInvestments[migrateArgs._user];\n\n        // Set all the epoch tracking values\n        currentUser.lastEpochUpdate = currentEpoch;\n\n        currentUser.lastClaimedTimestamp = block.timestamp;\n\n        currentUser.lastEpochLiquidityWithdrawn = currentEpoch;\n\n        currentUser.lastLiquidityAddedEpochReference = currentEpoch;\n\n        currentUser.bonusRewardMultiplier = migrateArgs._bonusRewardMultiplier;\n\n        // Calculate the epoch share for the user\n        uint256 epochShare = returnEpochShare(\n            migrateArgs._amount,\n            currentEpoch\n        );\n\n        // Update this specific users total\n        currentUser.epochTotals[currentEpoch].shareTotal = epochShare;\n\n        currentUser\n            .epochTotals[currentEpoch]\n            .currentInvestmentTotal = migrateArgs._amount;\n\n        // Update the totals for all the users\n        epochAmounts[currentEpoch].shareTotal = epochAmounts[currentEpoch]\n            .shareTotal\n            .add(epochShare);\n\n        epochAmounts[currentEpoch].currentInvestmentTotal = epochAmounts[\n            currentEpoch\n        ].currentInvestmentTotal.add(migrateArgs._amount);\n    }\n\n    function migrateUsersLPPositions(MigrateArgs[] calldata allMigrateArgs)\n        external\n        override\n    {\n        require(block.timestamp > epochStart, \"Epoch one hasn't started yet\");\n\n        require(\n            _msgSender() == migrationContractAddress,\n            \"Provider: Only the migration contract can call this function\"\n        );\n\n        uint256 currentEpoch = _returnEpochToTimestamp(block.timestamp);\n        uint256 transferTotal;\n\n        for (uint8 i = 0; i < allMigrateArgs.length; i++) {\n            transferTotal += allMigrateArgs[i]._amount;\n            saveMigrationUserDetails(allMigrateArgs[i], currentEpoch);\n        }\n\n        lastEpochUpdate = currentEpoch;\n\n        UniSwapToken.transferFrom(\n            migrationContractAddress,\n            address(this),\n            transferTotal\n        );\n    }\n\n    function returnAllClaimableRewardAmounts(address _user)\n        public\n        view\n        override\n        returns (\n            uint256 rewardTotal,\n            uint256 lastLiquidityAddedEpochReference,\n            uint256 lastEpochLiquidityWithdrawn\n        )\n    {\n        UserDetails storage currentUser = userInvestments[_user];\n\n        // If the user has no investments return 0\n        if (currentUser.lastEpochUpdate == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 currentEpoch = _returnEpochToTimestamp(block.timestamp);\n\n        // The last epoch they claimed from, to seed the start of the for-loop\n        uint256 lastEpochClaimed = _returnEpochToTimestamp(\n            currentUser.lastClaimedTimestamp\n        );\n\n        // To hold the users total in a given epoch\n        uint256 usersEpochTotal;\n\n        // To hold the overall total in a given epoch\n        uint256 overallEpochTotal;\n\n        // Reference to grab the user's latest epoch totals\n        uint256 lastLiquidityAddedEpochReference = currentUser\n            .lastLiquidityAddedEpochReference;\n\n        // Reference to grab the overall epoch totals\n        uint256 overallLastLiquidityAddedEpochReference = lastLiquidityAddedEpochReference;\n\n        uint256 lastEpochLiquidityWithdrawn = currentUser\n            .lastEpochLiquidityWithdrawn;\n\n        for (uint256 epoch = lastEpochClaimed; epoch <= currentEpoch; epoch++) {\n            // If the user withdrew liquidity in this epoch, update their reference for when they last withdrew liquidity\n            if (currentUser.epochTotals[epoch].withdrewLiquidity) {\n                lastEpochLiquidityWithdrawn = epoch;\n            }\n\n            // If the user did invest in this epoch, then their total investment amount is allTotals + shareAmount\n            if (currentUser.epochTotals[epoch].shareTotal != 0) {\n                // Update the reference for where to find values\n                if (lastLiquidityAddedEpochReference != epoch) {\n                    lastLiquidityAddedEpochReference = epoch;\n                }\n                // Update the user's total to include the share amount, as they invested in this epoch\n                usersEpochTotal = _returnEpochAmountIncludingShare(\n                    currentUser.epochTotals[epoch]\n                );\n            } else {\n                // Prevent this statement executing multiple times by only executing it after the epoch reference is updated or if the value hasn't been set yet\n                if (\n                    usersEpochTotal == 0 ||\n                    epoch == lastLiquidityAddedEpochReference.add(1)\n                ) {\n                    usersEpochTotal = _returnEpochAmountIncludingCurrentTotal(\n                        currentUser.epochTotals[\n                            lastLiquidityAddedEpochReference\n                        ]\n                    );\n                }\n            }\n\n            // If no rewards to be claimed for the current epoch, skip this loop\n            if (usersEpochTotal == 0) continue;\n\n            // If any user added amounts during this epoch, then update the overall total to include their share totals\n            if (epochAmounts[epoch].shareTotal != 0) {\n                // Update the reference of where to find an epoch total\n                if (overallLastLiquidityAddedEpochReference != epoch) {\n                    overallLastLiquidityAddedEpochReference = epoch;\n                }\n                // Set the overall epoch total to include the share\n                overallEpochTotal = _returnEpochAmountIncludingShare(\n                    epochAmounts[epoch]\n                );\n            } else {\n                // Prevent this statement executing multiple times by only executing it after the epoch reference is updated or if the value hasn't been set yet\n                if (\n                    overallEpochTotal == 0 ||\n                    epoch == overallLastLiquidityAddedEpochReference.add(1)\n                ) {\n                    overallEpochTotal = _returnEpochAmountIncludingCurrentTotal(\n                        epochAmounts[overallLastLiquidityAddedEpochReference]\n                    );\n                }\n            }\n\n            // Calculate the reward share for the epoch\n            uint256 epochRewardShare = _calculateRewardShareForEpoch(\n                epoch,\n                currentEpoch,\n                lastEpochClaimed,\n                currentUser.lastClaimedTimestamp,\n                usersEpochTotal,\n                overallEpochTotal\n            );\n\n            if (epoch != currentEpoch) {\n                uint256 epochsCompleteWithoutWithdrawal = 0;\n\n                if (lastEpochLiquidityWithdrawn < epoch) {\n                    epochsCompleteWithoutWithdrawal = epoch.sub(\n                        lastEpochLiquidityWithdrawn\n                    );\n                }\n\n                epochRewardShare = applyEpochRewardBonus(\n                    // Add the bonus reward multiplier to the reward multiplier\n                    epochsCompleteWithoutWithdrawal.add(\n                        currentUser.bonusRewardMultiplier\n                    ),\n                    epochRewardShare\n                );\n            }\n\n            rewardTotal = rewardTotal.add(epochRewardShare);\n        }\n\n        return (\n            rewardTotal,\n            lastLiquidityAddedEpochReference,\n            lastEpochLiquidityWithdrawn\n        );\n    }\n\n    function claimRewards(bool _sendRewardsToStaking, uint256 stakeDuration)\n        external\n        override\n        nonReentrant\n    {\n        UserDetails storage currentUser = userInvestments[_msgSender()];\n\n        // require the user to actually have an investment amount\n        require(\n            currentUser.lastEpochUpdate > 0,\n            \"User has no rewards to claim, as they have never added liquidity\"\n        );\n\n        (\n            uint256 allClaimableAmounts,\n            uint256 lastLiquidityAddedEpochReference,\n            uint256 lastEpochLiquidityWithdrawn\n        ) = returnAllClaimableRewardAmounts(_msgSender());\n\n        // If the user has never added liquidity, simply return and don't update any details onchain\n        if (lastLiquidityAddedEpochReference == 0) {\n            return;\n        }\n\n        currentUser\n            .lastLiquidityAddedEpochReference = lastLiquidityAddedEpochReference;\n\n        currentUser.lastEpochLiquidityWithdrawn = lastEpochLiquidityWithdrawn;\n\n        // Update their last claim to now\n        currentUser.lastClaimedTimestamp = block.timestamp;\n\n        // Return if no rewards to claim. Don't revert otherwise the user's details won't update to now and they will continually loop over epoch's that contain no rewards.\n        if (allClaimableAmounts == 0) {\n            return;\n        }\n\n        if (_sendRewardsToStaking) {\n            // Return a valid stake for the user\n            address usersStake = StakingMasterContract\n                .returnValidUsersProviderStake(_msgSender());\n\n            // If the stake is valid add the amount to it\n            if (usersStake != address(0)) {\n                StakingMasterContract.addToStake(\n                    usersStake,\n                    allClaimableAmounts\n                );\n                // Otherwise create a new stake for the user\n            } else {\n                // Stake duration must be greater than 0 if creating a new stake and sending the rewards there\n                require(\n                    stakeDuration > 0,\n                    \"Stake duration must be greater than 0 if rewards are being sent to staking\"\n                );\n\n                StakingMasterContract.createStaking(\n                    allClaimableAmounts,\n                    stakeDuration,\n                    _msgSender()\n                );\n            }\n            // If not sending the rewards to staking simply sends the rewards back to the user\n        } else {\n            AuroxToken.safeTransferFrom(\n                address(AuroxToken),\n                _msgSender(),\n                allClaimableAmounts\n            );\n        }\n\n        emit ClaimRewards(\n            _msgSender(),\n            allClaimableAmounts,\n            _sendRewardsToStaking\n        );\n    }\n\n    function removeLiquidity(uint256 _amount) external override nonReentrant {\n        UserDetails storage currentUser = userInvestments[_msgSender()];\n\n        // The epoch the user last added liquidity, this will give the latest version of their total amounts\n\n        EpochInvestmentDetails\n            storage usersLastAddedLiquidityEpochInvestmentDetails = currentUser\n                .epochTotals[currentUser.lastEpochUpdate];\n\n        // Calculate the user's total based on when they last added liquidity\n\n        uint256 usersTotal = _returnEpochAmountIncludingCurrentTotal(\n            usersLastAddedLiquidityEpochInvestmentDetails\n        );\n\n        // Ensure the user has enough amount to deduct the balance\n        require(\n            usersTotal >= _amount,\n            \"User doesn't have enough balance to withdraw the amount\"\n        );\n\n        uint256 currentEpoch = _returnEpochToTimestamp(block.timestamp);\n\n        // The users investment details for the current epoch\n        EpochInvestmentDetails\n            storage usersCurrentEpochInvestmentDetails = currentUser\n                .epochTotals[currentEpoch];\n\n        /* Calculate how much to remove from the user's share total if they have invested in the same epoch they are removing from */\n\n        // How many seconds they can claim from the current epoch\n        uint256 claimSecondsForPulledLiquidity = _returnClaimSecondsForPulledLiquidity(\n                currentUser.lastClaimedTimestamp,\n                currentEpoch\n            );\n\n        // How much the _amount is claimable since epoch start or when they last claimed rewards\n        uint256 claimAmountOnPulledLiquidity = _amount\n            .mul(claimSecondsForPulledLiquidity)\n            .div(epochLength);\n\n        // In the very rare case that they have no claim to the pulled liquidity, set the value to 1. This negates issues in the claim rewards function\n        if (claimAmountOnPulledLiquidity == 0) {\n            claimAmountOnPulledLiquidity = 1;\n        }\n\n        // If they have a share total in this epoch, then deduct it from the overall total and add the new calculated share total\n        if (usersCurrentEpochInvestmentDetails.shareTotal != 0) {\n            epochAmounts[currentEpoch].shareTotal = epochAmounts[currentEpoch]\n                .shareTotal\n                .sub(usersCurrentEpochInvestmentDetails.shareTotal);\n        }\n\n        // NOTE: They lose the reward amount they've earnt on a share total. If they add liqudiity and pull in same epoch they lose rewards earnt on the share total.\n        usersCurrentEpochInvestmentDetails\n            .shareTotal = claimAmountOnPulledLiquidity;\n\n        // If they haven't updated in this epoch. Pull the total forward minus the amount\n        if (currentUser.lastEpochUpdate != currentEpoch) {\n            // Update the overall total to refelct the updated amount\n            usersCurrentEpochInvestmentDetails\n                .allPrevInvestmentTotals = usersTotal.sub(_amount);\n\n            // Update when it was last updated\n            currentUser.lastEpochUpdate = currentEpoch;\n        } else {\n            // If there isn't enough in the allPrevInvestmentTotal for the subtracted amount\n            if (\n                usersLastAddedLiquidityEpochInvestmentDetails\n                    .allPrevInvestmentTotals < _amount\n            ) {\n                // Update the amount so it deducts the allPrevAmount\n                uint256 usersRemainingAmount = _amount.sub(\n                    usersLastAddedLiquidityEpochInvestmentDetails\n                        .allPrevInvestmentTotals\n                );\n\n                // Set the prev investment total to 0\n                usersCurrentEpochInvestmentDetails.allPrevInvestmentTotals = 0;\n\n                // Deduct from the currentInvestmentTotal the remaining _amount\n                usersCurrentEpochInvestmentDetails\n                    .currentInvestmentTotal = usersLastAddedLiquidityEpochInvestmentDetails\n                    .currentInvestmentTotal\n                    .sub(usersRemainingAmount);\n            } else {\n                // Subtract from their allPrevInvestmentTotal the amount to deduct and then update the user's total on the current epoch to be the new amounts\n                usersCurrentEpochInvestmentDetails\n                    .allPrevInvestmentTotals = usersLastAddedLiquidityEpochInvestmentDetails\n                    .allPrevInvestmentTotals\n                    .sub(_amount);\n\n                // Pull forward the current investment total\n                usersCurrentEpochInvestmentDetails\n                    .currentInvestmentTotal = usersLastAddedLiquidityEpochInvestmentDetails\n                    .currentInvestmentTotal;\n            }\n        }\n\n        // Update when the user last withdrew liquidity\n        usersCurrentEpochInvestmentDetails.withdrewLiquidity = true;\n\n        // Update the share total\n        epochAmounts[currentEpoch].shareTotal = epochAmounts[currentEpoch]\n            .shareTotal\n            .add(claimAmountOnPulledLiquidity);\n        // If the epoch amounts for this epoch haven't been updated\n        if (lastEpochUpdate != currentEpoch) {\n            uint256 overallEpochTotal = _returnEpochAmountIncludingCurrentTotal(\n                epochAmounts[lastEpochUpdate]\n            );\n\n            // Update the overall total to refelct the updated amount\n            epochAmounts[currentEpoch]\n                .allPrevInvestmentTotals = overallEpochTotal.sub(_amount);\n\n            // Update when it was last updated\n            lastEpochUpdate = currentEpoch;\n        } else {\n            // If there isnt enough in the total investment totals for the amount\n            if (epochAmounts[currentEpoch].allPrevInvestmentTotals < _amount) {\n                // Update the amount so it deducts the allPrevAmount\n                uint256 overallRemainingAmount = _amount.sub(\n                    epochAmounts[currentEpoch].allPrevInvestmentTotals\n                );\n\n                // Set the prev investment total to 0\n                epochAmounts[currentEpoch].allPrevInvestmentTotals = 0;\n\n                // Deduct from the currentInvestmentTotal the remaining _amount\n                epochAmounts[currentEpoch]\n                    .currentInvestmentTotal = epochAmounts[currentEpoch]\n                    .currentInvestmentTotal\n                    .sub(overallRemainingAmount);\n            } else {\n                // Subtract from their allPrevInvestmentTotal the amount to deduct and then update the user's total on the current epoch to be the new amounts\n                epochAmounts[currentEpoch]\n                    .allPrevInvestmentTotals = epochAmounts[currentEpoch]\n                    .allPrevInvestmentTotals\n                    .sub(_amount);\n\n                // Pull forward the current investment total\n                epochAmounts[currentEpoch]\n                    .currentInvestmentTotal = epochAmounts[currentEpoch]\n                    .currentInvestmentTotal;\n            }\n        }\n\n        // If the user is withdrawing in the first day of the epoch, then they get penalised no rewards\n        if (returnIfInFirstDayOfEpoch(currentEpoch)) {\n            UniSwapToken.safeTransfer(_msgSender(), _amount);\n        } else {\n            // Transfer 90% of the _amount to the user\n            UniSwapToken.safeTransfer(_msgSender(), _amount.mul(9).div(10));\n            // Transfer 10% to the burn address\n            UniSwapToken.safeTransfer(\n                0x0000000000000000000000000000000000000001,\n                _amount.div(10)\n            );\n        }\n\n        emit RemoveLiquidity(_msgSender(), _amount);\n    }\n}\n"
    },
    "contracts/Provider/IProvider.sol": {
      "content": "pragma solidity 0.8.10;\n\nimport \"./EpochHelpers.sol\";\n\ninterface IProvider {\n    struct UserDetails {\n        uint256 lastLiquidityAddedEpochReference;\n        // A number representing when the user last updated the epoch amounts\n        uint256 lastEpochUpdate;\n        // A timestamp representing when the user last claimed rewards\n        uint256 lastClaimedTimestamp;\n        // A number representing the epoch that liquidity was last drawn from\n        uint256 lastEpochLiquidityWithdrawn;\n        // A number representing the extra reward multiplier for V1 migrators\n        uint256 bonusRewardMultiplier;\n        // The mapping of epochs to investment details\n        mapping(uint256 => EpochHelpers.EpochInvestmentDetails) epochTotals;\n    }\n\n    struct MigrateArgs {\n        address _user;\n        uint256 _amount;\n        uint256 _bonusRewardMultiplier;\n    }\n\n    /**\n        @dev This function allows the migration contract to re-create LP positions for users. This function will iterate over all the migration arguments and at the end transfer the total amount into the LP contract.\n        @param allMigrateArgs All the users, their amounts and additional bonus rewards\n     */\n    function migrateUsersLPPositions(MigrateArgs[] calldata allMigrateArgs)\n        external;\n\n    /**\n        @dev Returns the current user's investment total in the provider\n        @param _user The user's address to return the total for\n        @return The user's stake total\n     */\n    function returnUsersInvestmentTotal(address _user)\n        external\n        view\n        returns (uint256);\n\n    /**\n        @dev The various investment values for a user based on a given epoch\n\n        @param epoch The given epoch to return the values for\n        @param _user The user to return totals for\n\n        @return shareTotal The user's proportional share total based on when they invested into the epoch\n        @return currentInvestmentTotal The user's raw investment total for the given epoch\n        @return allPrevInvestmentTotals The sum of all amounts made into the Provider contract at the current epoch's time\n     */\n    function returnUsersEpochTotals(uint256 epoch, address _user)\n        external\n        view\n        returns (\n            uint256 shareTotal,\n            uint256 currentInvestmentTotal,\n            uint256 allPrevInvestmentTotals\n        );\n\n    /**\n        @dev This function adds the liquidity to the provider contract and does all the work for the storage of epoch data, updating of totals, aggregating currentInvestmentTotal's and adding to the overall totals.\n\n        @param _amount The amount of liquidity to add\n     */\n    function addLiquidity(uint256 _amount) external;\n\n    /**\n        @dev This function returns the available amount to claim for the given user.\n\n        @param _user The address of the user to return the claimable amounts for\n        @return rewardTotal The reward total to return\n        @return lastLiquidityAddedEpochReference The last epoch where the user added liquidity\n     */\n    function returnAllClaimableRewardAmounts(address _user)\n        external\n        view\n        returns (\n            uint256 rewardTotal,\n            uint256 lastLiquidityAddedEpochReference,\n            uint256 lastEpochLiquidityWithdrawn\n        );\n\n    /**\n        @dev This functions claims all available rewards for the user, it looks through all epoch's since when they last claimed rewards and calculates the sum of their rewards to claim\n\n        @param _sendRewardsToStaking Whether the rewards are to be sent into a staking contract\n        @param stakeDuration The duration of the stake to be created\n     */\n    function claimRewards(bool _sendRewardsToStaking, uint256 stakeDuration)\n        external;\n\n    /**\n        @dev This function removes the specified amount from the user's total and sends their tokens back to the user. The user will be penalised 10% if withdrawing outside of the first day in any givene poch\n\n        @param _amount The amount to withdraw\n     */\n    function removeLiquidity(uint256 _amount) external;\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/Token/AuroxToken.sol": {
      "content": "pragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./TokenVesting.sol\";\nimport \"./IAuroxToken.sol\";\n\n// Ignoring the 19 states declaration for simpler deployment for the Aurox guys\ncontract AuroxToken is IAuroxToken, ERC20, Ownable {\n    TokenVesting public reservesVestingContract;\n    TokenVesting public teamRewardVestingContract;\n\n    constructor(\n        address uniSwapAddress,\n        address teamRewardAddress,\n        address exchangeListingReserve,\n        address reservesAddress\n    ) public ERC20(\"Aurox Token\", \"URUS\") {\n        // Mint the supply to the ERC20 address\n        _mint(_msgSender(), 1000000 ether);\n\n        transfer(address(this), 770000 ether);\n\n        // Create the vesting contracts\n        createVestingContracts(reservesAddress, teamRewardAddress);\n    }\n\n    // Expose a new function to update the allowance of a new contract\n    function setAllowance(address allowanceAddress)\n        external\n        override\n        onlyOwner\n    {\n        _approve(address(this), allowanceAddress, 650000 ether);\n\n        emit SetNewContractAllowance(allowanceAddress);\n    }\n\n    function createVestingContracts(\n        address reservesAddress,\n        address teamRewardAddress\n    ) private {\n        // Start vesting now\n        // Distribute linearly over 1 year\n        reservesVestingContract = new TokenVesting(\n            reservesAddress,\n            // Original reserves start time\n            1630315384,\n            0,\n            365 days,\n            false\n        );\n        // Distribute rewards over 1 yr\n        teamRewardVestingContract = new TokenVesting(\n            teamRewardAddress,\n            // Original Team vesting start time\n            1646040184,\n            0,\n            730 days,\n            false\n        );\n        // Start Time -> 1646040184\n        // Rough difference between start time and now: 15.3 days\n        // End Time -> 1709112184\n\n        // Because it hasn't started yet, can just update the start time to be: block.timestamp + 15 days\n    }\n}\n"
    },
    "contracts/Token/IAuroxToken.sol": {
      "content": "pragma solidity 0.8.10;\n\ninterface IAuroxToken {\n    event SetNewContractAllowance(address indexed _newAddress);\n\n    /**\n        @dev This function sets the allowance of a given contract to have access to the pool funds\n        @param allowanceAddress The address of the contract to set the allowance for\n     */\n    function setAllowance(address allowanceAddress) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}